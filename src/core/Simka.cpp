/****************************************************************************
 *   Simka: Fast kmer-based method for estimating the similarity between numerous metagenomic datasets
 *   A tool from the GATB (Genome Assembly Tool Box)
 *   Copyright (C) 2015  INRIA
 *   Authors: G.Benoit, C.Lemaitre, P.Peterlongo
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *****************************************************************************/

#include "Simka.hpp"
#include "SimkaAlgorithm.hpp"


IOptionsParser* Simka::createOptionsParser (IOptionsParser* parent)
{
    IOptionsParser* parser = parent; //new OptionsParser ("Simka");

	//Main parser
    parser->push_front (new OptionNoParam (STR_SIMKA_COMPUTE_DATA_INFO, "compute (and display) information before running Simka, such as the number of reads per dataset", false));
    parser->push_front (new OptionNoParam (STR_SIMKA_KEEP_TMP_FILES, "keep temporary files", false));
    parser->push_front (new OptionOneParam (STR_URI_OUTPUT_TMP, "output directory for temporary files", true));
    parser->push_front (new OptionOneParam (STR_URI_OUTPUT, "output directory for result files (distance matrices)", false, "./simka_results"));
    parser->push_front (new OptionOneParam (STR_URI_INPUT, "input file of samples. One sample per line: id1: filename1...", true));

    parser->push_back  (new OptionOneParam ("-matrix", "output matrix", false, "./simka_matrix.txt"));
    parser->push_back  (new OptionOneParam ("-groups", "groups file (generated by Simka-HowDeSBT.py)", false, "None"));
    parser->push_back  (new OptionNoParam ("-pipe", "stream matrix in pipe. -matrix option must be a path to fifo (mkfifo named_pipe)", false));

	parser->getParser(STR_NB_CORES)->setVisible(false);

    IOptionsParser* distanceParser = new OptionsParser ("distance");
    distanceParser->push_back (new OptionNoParam (STR_SIMKA_COMPUTE_ALL_SIMPLE_DISTANCES, "compute all simple distances (Chord, Hellinger...)", false));
    distanceParser->push_back (new OptionNoParam (STR_SIMKA_COMPUTE_ALL_COMPLEX_DISTANCES, "compute all complex distances (Jensen-Shannon...)", false));


	//Kmer parser
    IOptionsParser* kmerParser = new OptionsParser ("kmer");
    kmerParser->push_back (new OptionOneParam (STR_KMER_SIZE, "size of a kmer", false, "21"));
    kmerParser->push_back (new OptionOneParam (STR_KMER_ABUNDANCE_MIN, "min abundance a kmer need to be considered", false, "2"));
    kmerParser->push_back (new OptionOneParam (STR_KMER_ABUNDANCE_MAX, "max abundance a kmer can have to be considered", false, "999999999"));

    //kmerParser->push_back(dskParser->getParser (STR_SOLIDITY_KIND));
    //kmerParser->getParser (STR_SOLIDITY_KIND)->setHelp("TODO");
    //kmerParser->push_back (new OptionNoParam (STR_SIMKA_SOLIDITY_PER_DATASET.c_str(), "do not take into consideration multi-counting when determining solid kmers", false ));
    kmerParser->push_back (new OptionOneParam (STR_SIMKA_MIN_KMER_SHANNON_INDEX.c_str(), "minimal Shannon index a kmer should have to be kept. Float in [0,2]", false, "0" ));


    //Read filter parser
    IOptionsParser* readParser = new OptionsParser ("read");
    readParser->push_back (new OptionOneParam (STR_SIMKA_MAX_READS.c_str(), "maximum number of reads per sample to process. Can be -1: use all reads. Can be 0: estimate it", false, "-1" ));
    readParser->push_back (new OptionOneParam (STR_SIMKA_MIN_READ_SIZE.c_str(), "minimal size a read should have to be kept", false, "0" ));
    readParser->push_back (new OptionOneParam (STR_SIMKA_MIN_READ_SHANNON_INDEX.c_str(), "minimal Shannon index a read should have to be kept. Float in [0,2]", false, "0" ));

    //Core parser
    IOptionsParser* coreParser = new OptionsParser ("core");
    coreParser->push_back(new OptionOneParam(STR_NB_CORES, "number of cores", false, "0"));
    coreParser->push_back (new OptionOneParam (STR_MAX_MEMORY, "max memory (MB)", false, "5000"));



	parser->push_back(distanceParser);
	parser->push_back(kmerParser);
	parser->push_back(readParser);
	parser->push_back(coreParser);

	IOptionsParser* dskParser = SortingCountAlgorithm<>::getOptionsParser();

    if (Option* p = dynamic_cast<Option*> (dskParser->getParser(STR_MINIMIZER_SIZE)))  {  p->setDefaultValue ("7"); }
	parser->push_back(dskParser);
	dskParser->setVisible(false);
    if (Option* p = dynamic_cast<Option*> (parser->getParser(STR_SOLIDITY_KIND)))  {  p->setDefaultValue ("all"); }

    return parser;
}


Simka::Simka()  : Tool ("Simka")
{
	Simka::createOptionsParser(getParser());
}

struct Parameter
{
    Parameter (IProperties* props) : _props(props) {}
    IProperties* _props;
};

template<size_t span> struct Functor  {  void operator ()  (Parameter p)
{
	SimkaAlgorithm<span> simkaAlgorithm (p._props);
	simkaAlgorithm.execute();
}};

void Simka::execute ()
{
	IProperties* input = getInput();

	Parameter params(input);

	size_t kmerSize = getInput()->getInt (STR_KMER_SIZE);

    /** We launch the tool with the correct Integer implementation according to the choosen kmer size. */
    Integer::apply<Functor,Parameter> (kmerSize, params);
}
